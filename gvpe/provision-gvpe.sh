#!/usr/bin/env bash

set -e

ME="$(realpath ${0})"
NULL=
BASE_NETWORK="172.16.254"

[ ! -d systemd ] && mkdir -p systemd
[ ! -d keys ] && mkdir -p keys
[ ! -d conf.d ] && mkdir -p conf.d
[ ! -d conf.d/pubkey ] && mkdir -p conf.d/pubkey

run() {
    printf >&2 " > "
    printf >&2 "%q " "${@}"
    printf >&2 "\n"
    
    "${@}"
    return $?
}

cat >conf.d/gvpe.conf <<EOF
# DO NOT EDIT - automatically generated by ${ME}

enable-udp = yes
udp-port = 49999 # the external port to listen on (configure your firewall)

enable-tcp = yes
tcp-port = 49999 # the external port to listen on (configure your firewall)

# Sets the maximum MTU that should be used on outgoing packets (basically the
# MTU of the outgoing interface) The daemon will automatically calculate
# maximum overhead (e.g. UDP header size, encryption blocksize...) and pass
# this information to the if-up script.
# Recommended values are 1500 (ethernet), 1492 (pppoe), 1472 (pptp).
# This value must be the minimum of the MTU values of all nodes.
mtu = 1400       # minimum MTU of all outgoing interfaces on all hosts

# the local network device name
ifname = vpn0

# Sets the keepalive probe interval in seconds (default: 60).
# After this many seconds of inactivity the daemon will start to send keepalive
# probe every 3 seconds until it receives a reply from the other end.
# If no reply is received within 15 seconds, the peer is considered unreachable
# and the connection is closed.
keepalive = 10

# loglevel = noise|trace|debug|info|notice|warn|error|critical
loglevel = info

# nfmark = integer
# This advanced option, when set to a nonzero value (default: 0), tries to set
# the netfilter mark (or fwmark) value on all sockets gvpe uses to send packets.
#nfmark = 0

if-up = if-up
node-up = node-up
node-change = node-change
node-down = node-down

private-key = hostkey

# Sets the rekeying interval in seconds (default: 3607).
# Connections are reestablished every rekey seconds, making them use a new
# encryption key.
rekey = 3600

# The configuration serial number. This can be any string up to 16 bytes
# length. Only when the serial matches on both sides of a connection will the
# connection succeed. This is not a security mechanism and eay to spoof, this
# mechanism exists to alert users that their config is outdated.
serial = $(date +%Y%m%d%H%M%S)

EOF

cat >conf.d/hosts.real <<EOF
# BEGIN gvpe real
# DO NOT EDIT - automatically generated by ${ME}
EOF

cat >conf.d/hosts.vpn <<EOF
# BEGIN gvpe vpn
# DO NOT EDIT - automatically generated by ${ME}
EOF

declare -A unique_names=()
declare -A unique_pips=()
declare -A unique_vips=()

all=
for h in \
    box:195.97.5.206:${BASE_NETWORK}.1:none \
    costa:dynamic:${BASE_NETWORK}.2:none \
    london:139.59.166.55:${BASE_NETWORK}.10:linux \
    atlanta:185.93.0.89:${BASE_NETWORK}.20:linux \
    west-europe:13.93.125.124:${BASE_NETWORK}.30:linux \
    bangalore:139.59.0.212:${BASE_NETWORK}.40:linux \
    frankfurt:46.101.193.115:${BASE_NETWORK}.50:linux \
    sanfrancisco:104.236.149.236:${BASE_NETWORK}.60:linux \
    toronto:159.203.30.96:${BASE_NETWORK}.70:linux \
    singapore:128.199.80.131:${BASE_NETWORK}.80:linux \
    newyork:162.243.236.205:${BASE_NETWORK}.90:linux \
    aws-fra:35.156.164.190:${BASE_NETWORK}.100:linux \
    netdata-build-server:40.68.190.151:${BASE_NETWORK}.110:linux \
    ${NULL}
do
    all="${all} ${h}"
    name=$(echo "${h}" | cut -d ':' -f 1)
    pip=$(echo "${h}" | cut -d ':' -f 2)
    vip=$(echo "${h}" | cut -d ':' -f 3)
    os=$(echo "${h}" | cut -d ':' -f 4)

    hostname_comment=
    connect="always"
    [ "${pip}" = "dynamic" ] && connect="never" && hostname_comment="# "

    [ ! -z "${unique_names[${name}]}" ] && echo >&2 "Name '${name}' for IP ${pip} already exists with IP ${unique_names[${name}]}." && exit 1
    [ "${pip}" != "dynamic" -a ! -z "${unique_pips[${pip}]}" ] && echo >&2 "Public IP '${pip}' for ${name} already exists for ${unique_pips[${pip}]}." && exit 1
    [ ! -z "${unique_vips[${vip}]}" ] && echo >&2 "VPN IP '${vip}' for ${name} already exists for ${unique_vips[${vip}]}." && exit 1
    
    unique_names[${name}]="${pip}"
    unique_pips[${pip}]="${name}"
    unique_vips[${vip}]="${name}"

    if [ "${pip}" != "dynamic" ]
        then
        printf "%-15s %s\n" "${pip}" "${name}" >>conf.d/hosts.real
    fi

    printf "%-15s %s\n" "${vip}" "${name}" >>conf.d/hosts.vpn

    cat >>conf.d/gvpe.conf <<EOF

node = ${name}
compress = yes
on ${name} hostname = 0.0.0.0
${hostname_comment}on !${name} hostname = ${pip}
on !${name} connect = ${connect}  # ondemand | never | always | disabled
on ${name} if-up-data = ${vip}|${BASE_NETWORK}.0/24
inherit-tos = yes
max-retry = 120
max-ttl = 60
max-queue = 512
router-priority = 1
# allow-direct = 
# deny-direct =
# low-power = yes # on laptops
EOF

    cat >systemd/${name}.service <<EOF
# DO NOT EDIT - automatically generated by ${ME}
[Unit]
Description=gvpe
After=network.target
Before=remote-fs.target

[Service]
ExecStart=/usr/local/sbin/gvpe -c /etc/gvpe -D ${name}
KillMode=process
Restart=always

[Install]
WantedBy=multi-user.target
EOF

    if [ ! -f "keys/${name}" -o ! -f "keys/${name}.privkey" ]
    then
        echo >&2 "generating keys for: ${name}"
        cd keys
        run ../sbin/gvpectrl -c ../conf.d -g ${name}
        cd ..
    fi
    if [ ! -f "conf.d/pubkey/${name}" ]
    then
        run cp keys/${name} conf.d/pubkey/${name}
    fi
done

echo "# END gvpe real" >>conf.d/hosts.real
echo "# END gvpe vpn"  >>conf.d/hosts.vpn

for h in ${all}
do
    name=$(echo "${h}" | cut -d ':' -f 1)
    pip=$(echo "${h}" | cut -d ':' -f 2)
    vip=$(echo "${h}" | cut -d ':' -f 3)
    os=$(echo "${h}" | cut -d ':' -f 4)

    # do not provision hosts with O/S set to 'none'
    [ "${os}" = "none" ] && continue
    # [ "${name}" = "london" ] && continue

    echo >&2
    echo >&2 "Provisioning: ${name}"

    if [ "${os}" = "linux" ]
        then
        run rsync -HaSPv sbin/ ${pip}:/usr/local/sbin/
    fi

    run rsync -HaSPv conf.d/ ${pip}:/etc/gvpe/
    run scp keys/${name}.privkey ${pip}:/etc/gvpe/hostkey
    
    systemd=1
    run scp systemd/${name}.service ${pip}:/etc/systemd/system/gvpe.service || systemd=0
    
    failed=0
    if [ $systemd -eq 1 ]
    then
        ssh "${pip}" "systemctl daemon-reload && systemctl restart gvpe" || failed=1
    else
        ssh "${pip}" killall -HUP gvpe || failed=1
    fi
    
    if [ $failed -eq 1 ]
    then
        echo >&2 "Failed to restart gvpe on ${name} at ${pip}"
    fi
done
